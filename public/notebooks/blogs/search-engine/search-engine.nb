{
  "cells": [
    {
      "cell_type": "markdown",
      "source": "<p>Search engines are ubiquitous. Google, Bing, Yahoo, you name it, all of these are internet-wide search engines. Even your favorite social media platforms have a search functionality. How do they work? How can we build our own? And how can we build a search engine which is cheap and easy to run?</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h1>Introduction to the Search Problem</h1>\n<p>Search engines are ubiquitous. Google, Bing, Yahoo, you name it, all of these are internet-wide search engines. Even your favorite social media platforms have a search functionality. How do they work? How can we build our own? And how can we build a search engine which is cheap and easy to run?<br />\n<br /></p>\n<p>This article is written with the first-principles approach. Rather than jumping straight into established methods, I‚Äôm starting with something familier - a textbook, and building a search engine with the natural patterns I use to find a topic in the textbook. This article takes an iterative approach to achieve a strong, yet simple, search engine.</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Chapters üìö</h2>\n<ol>\n<li><a href=\"/blog/search-engine\"><strong>Introduction to the Search Problem</strong></a></li>\n<li><a href=\"/blog/search-engine-2\">Data acquisition, normalization and cleaning</a></li>\n<li><a href=\"/blog/search-engine-3\">Reverse Index and Search</a></li>\n<li><a href=\"/blog/search-engine-4\">Workshop - Build a Search Engine</a></li>\n<li><a href=\"/blog/search-engine-5\">Workshop - Build a Search Engine (solution)</a></li>\n<li><a href=\"/blog/search-engine-6\">Token-frequency optimization and Zipf‚Äôs law</a></li>\n</ol>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Background üåÖ</h2>\n<p>I wanted to add search functionality to this website, but there‚Äôs a catch - this site is entirely backend-free by design and I intend to keep it that way. Running a backend adds costs, requires maintenance, and introduces scaling challenges, which I want to avoid.</p>\n<p>Additionally, instead of researching existing search engine architectures, I‚Äôm taking a first-principles approach. Rather than jumping straight into established methods, I‚Äôm starting with something familiar - a textbook. How do I naturally find a topic in a textbook? What patterns do I rely on? By deconstructing my own search process, I aim to build a search engine from scratch, refining it step by step.</p>\n<p>This article is a log of that journey, an attempt to understand search from the ground up, experiment with solutions, and iteratively improve them along the way.</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Goals ‚õ≥Ô∏è</h2>\n<p>Search engines are ubiquitous - almost every major social media platform uses one, and, as the elephant in the room, you have behemoths such as Google, Bing and others. But how do they work? And how can we build our own? And how can we keep it cheap and simple to use?</p>\n<p>Some goals for this project:</p>\n<ul>\n<li>Learn how search engines work</li>\n<li>Learn some NLP (natural language processing) techniques</li>\n<li>Achieve a decent accuracy</li>\n</ul>\n<p>Additional challenges and constraints, since I can‚Äôt keep things simple üòÉ:</p>\n<ul>\n<li>Search should have no backend, and be run 100% in the browser</li>\n<li>Search should support unicode. Languages other than English exist, oh, and don‚Äôt forget about Emojis!</li>\n</ul>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Tools Used üõ†Ô∏è</h2>\n<ul>\n<li>Node.js (v22.13.0)</li>\n<li><a href=\"https://www.cs.cmu.edu/~enron/\">Enron Emails Dataset</a> - used for large scale test data</li>\n<li><a href=\"https://www.gutenberg.org/ebooks/21\">√Üsop‚Äôs Fables</a> - used for test data in our demos</li>\n<li>Web Browser with JavaScript support</li>\n</ul>\n<blockquote>\n<p><strong>Notes</strong>:</p>\n<ol>\n<li>for √Üsop‚Äôs fables, the text version of the Project Gutenberg archive was transformed into JSON for ease of use. The processing of the Project Gutenberg text is outside the scope of this project, and the processing may have some errors.</li>\n<li>The majority of code will be written in JavaScript, due to the goal of being able to run search 100% on the browser.</li>\n</ol>\n</blockquote>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Search, The Problem üëÄ</h2>\n<p>Once upon a time, the internet was in its infancy, Google was still under development, and CLRS, The legendary <em>Introduction to Algorithms</em> textbook was just published. But none of that mattered, you had a biology assignment due which required you to understand <em>prokaryotic organisms</em>. While the Internet offered little in help, your best resource sat in front of you - <strong>a biology textbook</strong>!</p>\n<p>Now, take a moment and think‚Ä¶ How do you find a topic in a textbook?</p>\n<p>You <em>could</em> read the entire textbook, every single page, and find out more about <em>prokaryotic organisms</em>, but is that your best approach? Do you have the time to read through every single page for your assignment? Probably not. Thus, we need to do better and use the resources we have available to ourselves to find a better process.</p>\n<p>What resources does the textbook provide you to efficiently find what you are looking for?</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Search, The Textbook Method üóÇÔ∏è</h2>\n<p>Textbooks normally have two tools, available to your disposal, to help you find information quickly:</p>\n<ol>\n<li><strong>Table of Contents (TOC)</strong> at the beginning</li>\n<li><strong>Index</strong> at the end</li>\n</ol>\n<p>Each of these tools work differently from each other, but together, they make searching for topics much faster than flipping through pages.</p>\n<blockquote>\n<p>The <strong>Table of Contents</strong> is like a roadmap, listing chapters and sections in order, allowing you to navigate through a book top-down.</p>\n<p>For example, if you need to learn about bacteria, the TOC might tell you:</p>\n<p>üìñ Chapter 3: Bacteria and Prokaryotes (Page 45)</p>\n<p>This tells you where to start reading about bacteria. But if you need something very specific‚Äîlike ‚ÄúGram-positive bacteria‚Äù‚Äîyou might not find that in the TOC.</p>\n<br />\n<p>The <strong>Index</strong> maps topics and terms to their location. Instead of listing topics by chapters, it lists every single important word or term in <strong>alphabetical order</strong>, along with the exact page numbers.</p>\n<p>For example, if you need <em>Gram-positive Bacteria</em>, you can check the index:</p>\n<p>üîç Gram-positive bacteria ‚Äì Pages 26, 28, 47</p>\n<p>Now, you can go straight to the exact pages without reading everything before it.</p>\n</blockquote>\n<p>Can we model a simple search engine off the same process used to find a topic in a book?</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2>Attempting to Create a High-Level Overview üç≥</h2>\n<p>Before diving into implementation, let‚Äôs break down the core components of a search system by asking two key questions:</p>\n<ul>\n<li>What components are necessary for search?</li>\n<li>What role does each component play?</li>\n</ul>\n<h3>Data Acquisition üèóÔ∏è</h3>\n<p>Before we can search anything, we need to gather and prepare the data. This involves two key steps:</p>\n<ol>\n<li>üß∫ Gather the data\n<ol>\n<li>On the internet: render pages, find links and follow links, downloading the rendered website</li>\n<li>Local: recursively find files in a directory, read them</li>\n</ol>\n</li>\n<li>üßº Clean up the data - prepare the data so it can be searched\n<ol>\n<li>Clean up unicode code points</li>\n<li>Identify meaningful sections and metadata</li>\n<li>Standardize formatting for consistent searchability</li>\n</ol>\n</li>\n</ol>\n<p>Once we acquire and clean up data, we face a design decision: Do we preprocess heavily upfront to enable efficient search later OR do we store raw data and brute-force search at query time?</p>\n"
    },
    {
      "cell_type": "markdown",
      "source": "<h2><a href=\"/blog/search-engine-2\">Next: We will Acquire Data and Clean it up ‚è≠Ô∏è</a></h2>\n<p>In the next section, we will acquire data, clean it up and prepare it for search.</p>\n"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.13.1"
    },
    "img": {},
    "pageinfo": {
      "root": "deep-dive",
      "name": "search-engines",
      "page": 1,
      "author": "yash101",
      "title": "Search Engines - a Beginner-Friendly Deep Dive",
      "subtitle": "Learn how search engines work and attempt to build your own!",
      "lastModifiedOn": "2025-02-07T20:56:17.277Z",
      "publishedOn": "2025-02-07T00:00:00.277Z",
      "isPublished": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5,
  "additionalRawHtml": "\n<style type=\"text/css\">\nmjx-container[jax=\"SVG\"] > svg {\n  display: inline;\n  z-index: 0;\n  max-width: 100%;\n  overflow-x: auto;\n}\n\nmjx-container[jax=\"SVG\"] {\n  direction: ltr;\n}\n\nmjx-container[jax=\"SVG\"] > svg {\n  overflow: visible;\n  min-height: 1px;\n  min-width: 1px;\n}\n\nmjx-container[jax=\"SVG\"] > svg a {\n  fill: blue;\n  stroke: blue;\n}\n\nmjx-assistive-mml {\n  position: absolute !important;\n  top: 0px;\n  left: 0px;\n  clip: rect(1px, 1px, 1px, 1px);\n  padding: 1px 0px 0px 0px !important;\n  border: 0px !important;\n  display: block !important;\n  width: auto !important;\n  overflow: hidden !important;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\nmjx-assistive-mml[display=\"block\"] {\n  width: 100% !important;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"] {\n  display: block;\n  text-align: center;\n  margin: 1em 0;\n}\n\nmjx-container[jax=\"SVG\"][display=\"true\"][width=\"full\"] {\n  display: flex;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"left\"] {\n  text-align: left;\n}\n\nmjx-container[jax=\"SVG\"][justify=\"right\"] {\n  text-align: right;\n}\n\ng[data-mml-node=\"merror\"] > g {\n  fill: red;\n  stroke: red;\n}\n\ng[data-mml-node=\"merror\"] > rect[data-background] {\n  fill: yellow;\n  stroke: none;\n}\n\ng[data-mml-node=\"mtable\"] > line[data-line], svg[data-table] > g > line[data-line] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {\n  stroke-width: 70px;\n  fill: none;\n}\n\ng[data-mml-node=\"mtable\"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {\n  stroke-dasharray: 140;\n}\n\ng[data-mml-node=\"mtable\"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {\n  stroke-linecap: round;\n  stroke-dasharray: 0,140;\n}\n\ng[data-mml-node=\"mtable\"] > g > svg {\n  overflow: visible;\n}\n\n[jax=\"SVG\"] mjx-tool {\n  display: inline-block;\n  position: relative;\n  width: 0;\n  height: 0;\n}\n\n[jax=\"SVG\"] mjx-tool > mjx-tip {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\nmjx-tool > mjx-tip {\n  display: inline-block;\n  padding: .2em;\n  border: 1px solid #888;\n  font-size: 70%;\n  background-color: #F8F8F8;\n  color: black;\n  box-shadow: 2px 2px 5px #AAAAAA;\n}\n\ng[data-mml-node=\"maction\"][data-toggle] {\n  cursor: pointer;\n}\n\nmjx-status {\n  display: block;\n  position: fixed;\n  left: 1em;\n  bottom: 1em;\n  min-width: 25%;\n  padding: .2em .4em;\n  border: 1px solid #888;\n  font-size: 90%;\n  background-color: #F8F8F8;\n  color: black;\n}\n\nforeignObject[data-mjx-xml] {\n  font-family: initial;\n  line-height: normal;\n  overflow: visible;\n}\n\nmjx-container[jax=\"SVG\"] path[data-c], mjx-container[jax=\"SVG\"] use[data-c] {\n  stroke-width: 3;\n}\n\n</style>\n    "
}